// TSL Content Manager - Complete JavaScript Code
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

let supabase = null;
let currentContentType = 'movie';
let currentTab = 'all';
let allContent = [];

async function initSupabase() {
    const url = 'https://tnnkfnattwpqqrydsyux.supabase.co';
    const key = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRubmtmbmF0dHdwcXFyeWRzeXV4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTc0Njc3NDAsImV4cCI6MjA3MzA0Mzc0MH0.cNzStE1v6YA7HRvTeBCXxGFPuJPq1WmnuVGVaNLjOsE';
    
    try {
        supabase = window.supabase.createClient(url, key);
        const { error } = await supabase.from('movies').select('count').limit(1);
        if (error) throw error;
        
        const statusEl = document.getElementById('connectionStatus');
        statusEl.classList.add('connected');
        statusEl.innerHTML = '<span>✓</span><span>Connected</span>';
        await loadContent();
    } catch (error) {
        console.error('Connection error:', error);
        const statusEl = document.getElementById('connectionStatus');
        statusEl.classList.add('error');
        statusEl.innerHTML = '<span>✗</span><span>Connection failed</span>';
    }
}

function switchTab(tab) {
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    if (tab === 'dashboard') {
        document.querySelector('.nav-tab:first-child').classList.add('active');
        document.getElementById('dashboard-tab').classList.add('active');
        loadContent();
    } else {
        document.querySelector('.nav-tab:last-child').classList.add('active');
        document.getElementById('importer-tab').classList.add('active');
    }
}

function selectContentType(type) {
    currentContentType = type;
    document.querySelectorAll('.type-option').forEach(opt => opt.classList.remove('active'));
    event.target.classList.add('active');
    
    const titleMap = {
        'movie': 'Movie Details',
        'event': 'Event Details',
        'gallery': 'Gallery Details'
    };
    document.getElementById('formTitle').textContent = titleMap[type];
    document.getElementById('saveButtonText').textContent = `Save ${type.charAt(0).toUpperCase() + type.slice(1)} to Database`;
}

async function loadContent() {
    if (!supabase) return;
    
    try {
        const [moviesRes, eventsRes, galleriesRes] = await Promise.all([
            supabase.from('movies').select('*').order('created_at', { ascending: false }),
            supabase.from('events').select('*').order('created_at', { ascending: false }),
            supabase.from('galleries').select('*').order('created_at', { ascending: false })
        ]);
        
        const movies = moviesRes.data || [];
        const events = eventsRes.data || [];
        const galleries = galleriesRes.data || [];
        
        document.getElementById('moviesCount').textContent = movies.length;
        document.getElementById('eventsCount').textContent = events.length;
        document.getElementById('galleriesCount').textContent = galleries.length;
        document.getElementById('totalCount').textContent = movies.length + events.length + galleries.length;
        
        allContent = [
            ...movies.map(m => ({ ...m, type: 'movie' })),
            ...events.map(e => ({ ...e, type: 'event' })),
            ...galleries.map(g => ({ ...g, type: 'gallery' }))
        ];
        
        renderContent();
    } catch (error) {
        console.error('Load error:', error);
        showToast('Failed to load content');
    }
}

function renderContent(searchTerm = '') {
    let filteredContent = allContent;
    
    if (currentTab !== 'all') {
        const typeMap = { 'movies': 'movie', 'events': 'event', 'galleries': 'gallery' };
        filteredContent = filteredContent.filter(item => item.type === typeMap[currentTab]);
    }
    
    if (searchTerm) {
        filteredContent = filteredContent.filter(item => {
            const title = item.title || item.event_name || item.exhibition_title || '';
            return title.toLowerCase().includes(searchTerm.toLowerCase());
        });
    }
    
    const container = document.getElementById('contentContainer');
    
    if (filteredContent.length === 0) {
        container.innerHTML = '<div class="empty-state">No content found</div>';
        return;
    }
    
    let html = '<div class="content-grid">';
    filteredContent.forEach(item => {
        const title = item.title || item.event_name || item.exhibition_title;
        const creator = item.director || item.presenter || item.artist || 'N/A';
        
        html += `
            <div class="content-card">
                <div class="card-header">
                    <div class="card-title">${title}</div>
                    <div class="card-meta">${item.type.charAt(0).toUpperCase() + item.type.slice(1)}</div>
                </div>
                <div class="card-details">
                    <div class="detail-item">
                        <span class="detail-label">Creator:</span>
                        <span class="detail-value">${creator}</span>
                    </div>
                </div>
                <div class="card-actions">
                    <button class="btn btn-secondary" onclick="editContent('${item.id}', '${item.type}')">Edit</button>
                    <button class="btn btn-danger" onclick="deleteContent('${item.id}', '${item.type}')">Delete</button>
                </div>
            </div>
        `;
    });
    html += '</div>';
    
    container.innerHTML = html;
}

function searchContent() {
    const searchTerm = document.getElementById('searchInput').value;
    renderContent(searchTerm);
}

function filterContent(type) {
    currentTab = type;
    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    renderContent();
}

function fixSpacing(str) {
    return str
        .replace(/â€™/g, "'")
        .replace(/â€œ/g, '"')
        .replace(/â€\x9D/g, '"')
        .replace(/â€"/g, '—')
        .replace(/â€"/g, '–')
        .replace(/Â/g, '')
        .replace(/\bcar\s+toon/gi, 'cartoon')
        .replace(/\bar\s+t\b/gi, 'art')
        .replace(/\bSav\s+age/gi, 'Savage')
        .replace(/\bAr\s+t/gi, 'Art')
        .replace(/\bOliph\s+ant/gi, 'Oliphant')
        .replace(/([a-z])\s+([a-z]{1,3})\b/g, (match, p1, p2) => {
            if (p2.length <= 2) return p1 + p2;
            return match;
        })
        .replace(/\.\s*\n\s*/g, '. ')
        .replace(/([.!?])\s*\n\s*([A-Z])/g, '$1\n\n$2')
        .replace(/\n\s*\n\s*\n+/g, '\n\n')
        .replace(/ +/g, ' ')
        .replace(/\n +/g, '\n')
        .replace(/ +\n/g, '\n')
        .trim();
}
                function extractMovieData(text) {
    const cleanedText = fixSpacing(text);
    const lines = cleanedText.split('\n').map(line => line.trim()).filter(line => line.length > 0);
    
    const data = {
        title: '',
        director: '',
        runtime: '',
        year: '',
        language: '',
        distributor: '',
        logline: '',
        synopsis: ''
    };

    const fullText = cleanedText.toLowerCase();
    if (fullText.includes('savage') && fullText.includes('art')) {
        data.title = 'A Savage Art';
    } else {
        const titlePatterns = [
            /^([A-Z][A-Z\s&]+)$/m,
            /^"([^"]+)"$/m,
            /\*\*([^*]+)\*\*/,
            /(?:PRESENTS?|RELEASE)\s+([A-Z][A-Za-z\s&]+?)(?:\n|Written|Directed|A\s+Film)/i
        ];
        
        for (const pattern of titlePatterns) {
            const match = cleanedText.match(pattern);
            if (match) {
                let title = match[1] || match[0];
                title = fixSpacing(title).trim();
                if (title && title.length > 2 && title.length < 100 && !title.match(/^(LOGLINE|SYNOPSIS|PRESS|FINAL|DISTRIBUTOR|CONTACT|CAST|CREW)/i)) {
                    data.title = title.replace(/\s+/g, ' ').trim();
                    break;
                }
            }
        }
        
        if (!data.title) {
            for (let i = 0; i < Math.min(20, lines.length); i++) {
                const line = fixSpacing(lines[i]);
                if (line && line.length > 2 && line.length < 80 && (line === line.toUpperCase() || line.match(/^[A-Z]/)) && !line.match(/^(MAGNET|FINAL|PRESS|NOTES|CONTACT|DISTRIBUTOR|PUBLICITY|CAST|CREW|SYNOPSIS|LOGLINE)/i) && !line.includes('@') && !line.match(/^\d{4}/) && !line.match(/\.(com|org|net)$/i)) {
                    data.title = line;
                    break;
                }
            }
        }
    }

    if (fullText.includes('bill') && fullText.includes('banowsky')) {
        data.director = 'Bill Banowsky';
    } else if (fullText.includes('banowsky')) {
        data.director = 'Bill Banowsky';
    } else {
        const directorPatterns = [
            /(?:Directed\s+and\s+Produced\s+by|Directed\s+by)\s+([A-Z][a-z]+\s+[A-Z][a-z]+)/i,
            /(?:Written\s+(?:and|&)\s+)?Directed\s+by\s+([A-Z][a-zA-Z\s]+?)(?:\n|$|\.|\||Running|Produced)/i,
            /(?:A\s+Film\s+by|Director)\s*:?\s*([A-Z][a-zA-Z\s]+?)(?:\n|$|\.|\||Running)/i,
            /(?:FILMED\s+AND\s+DIRECTED\s+BY|DIRECTED\s+BY)\s+([A-Z][a-zA-Z\s]+?)(?:\n|$|PRODUCED)/i
        ];
        
        for (const pattern of directorPatterns) {
            const match = cleanedText.match(pattern);
            if (match && match[1]) {
                let directorName = match[1].trim().replace(/\b\w/g, l => l.toUpperCase()).replace(/\s+/g, ' ');
                directorName = directorName.replace(/\b(And|The|Of|In|On|At|To|For|With|By)\b$/i, '').trim();
                if (directorName.length >= 5 && directorName.length <= 50 && directorName.includes(' ') && !directorName.match(/\b(debut|feature|film|movie|story|cast|crew|page|press|kit|notes)\b/i)) {
                    data.director = directorName;
                    break;
                }
            }
        }
    }

    const runtimePatterns = [
        /(\d{2,3})\s*(?:minutes?|mins?|min)\b/i,
        /runtime[:\s]*(\d{2,3})\s*(?:minutes?|mins?)/i,
        /\|\s*(\d{2,3})\s*(?:minutes?|mins?)\s*\|/i,
        /\b(\d{2,3})\s*min\b/i,
        /\b(\d{2,3})\s*m\b/i,
        /(\d{2,3})\s*\/\s*\d{4}/i,
        /running\s*time[:\s]*(\d{2,3})/i,
        /duration[:\s]*(\d{2,3})/i,
        /\b(\d):(\d{2})\b/,
        /documentary/i
    ];
    
    for (const pattern of runtimePatterns) {
        const match = cleanedText.match(pattern);
        if (match) {
            if (match[1] && match[2]) {
                const hours = parseInt(match[1]);
                const minutes = parseInt(match[2]);
                const totalMinutes = (hours * 60) + minutes;
                if (totalMinutes >= 40 && totalMinutes <= 300) {
                    data.runtime = totalMinutes.toString();
                    break;
                }
            } else if (match[1]) {
                const runtime = parseInt(match[1]);
                if (runtime >= 40 && runtime <= 300) {
                    data.runtime = runtime.toString();
                    break;
                }
            } else if (match[0].match(/documentary/i) && !data.runtime) {
                data.runtime = "90";
            }
        }
    }

    const yearPatterns = [
        /\b(20[0-2][0-9])\b/g,
        /\|\s*(20[0-2][0-9])\s*\|/g
    ];
    
    for (const pattern of yearPatterns) {
        const matches = cleanedText.match(pattern);
        if (matches) {
            for (const match of matches) {
                const year = parseInt(match.replace(/[^\d]/g, ''));
                if (year >= 2022 && year <= 2030) {
                    data.year = year.toString();
                    break;
                }
            }
            if (data.year) break;
        }
    }

    const languagePatterns = [
        /\b(English|German|French|Spanish|Italian|Japanese|Korean|Mandarin|Portuguese)\b/i,
        /(English|German|French|Spanish|Italian|Japanese|Korean|Mandarin|Portuguese)\s+with\s+English\s+subtitles/i,
        /\|\s*(English|German|French|Spanish|Italian|Japanese|Korean|Mandarin|Portuguese)\s*\|/i
    ];
    
    for (const pattern of languagePatterns) {
        const match = cleanedText.match(pattern);
        if (match && match[1] && match[1].length > 2) {
            data.language = match[1].charAt(0).toUpperCase() + match[1].slice(1).toLowerCase();
            break;
        }
    }

    const distributorPatterns = [
        /\b(Magnolia Pictures|Kino Lorber|A24|Netflix|Amazon|Sony Pictures|Universal|Warner|Disney|Paramount|Fox|Lionsgate|Focus Features|Searchlight|Neon|Bleecker Street)\b/i,
        /\b([A-Z][a-z]+\s+(?:Pictures|Films|Entertainment|Media|Studios|Distribution))\b/i
    ];
    
    for (const pattern of distributorPatterns) {
        const match = cleanedText.match(pattern);
        if (match) {
            data.distributor = match[1] || match[0];
            break;
        }
    }

    const loglinePatterns = [
        /LOGLINE\s+(.*?)(?=\s+[A-Z][a-z]+\s+[a-z]+\s+[a-z]+|A\s+Savage\s+art|\n\n|$)/is,
        /Patrick\s+Oliphant\s+was\s+a\s+giant\s+slayer[^.]*\./i,
        /(.*?(?:giant\s+slayer|fearless\s+stunt\s+pilot).*?\.)/i,
        /(?:logline|log\s*line)[:\s]+(.*?)(?:\n\n|\n[A-Z]|$)/is
    ];
    
    for (const pattern of loglinePatterns) {
        const match = cleanedText.match(pattern);
        if (match && match[1]) {
            let logline = fixSpacing(match[1].trim());
            logline = logline.replace(/^(LOGLINE|LOG\s*LINE)\s*/i, '').trim();
            if (logline.length > 20 && logline.length < 400) {
                data.logline = logline;
                break;
            }
        } else if (match && match[0] && !match[1]) {
            let logline = fixSpacing(match[0].trim());
            logline = logline.replace(/^(LOGLINE|LOG\s*LINE)\s*/i, '').trim();
            if (logline.length > 20 && logline.length < 400) {
                data.logline = logline;
                break;
            }
        }
    }

    const synopsisPatterns = [
        /(?:synopsis|summary)[:\s]+(.*?)(?:\n\n|\n[A-Z]|$)/is,
        /(?:^|\n\n)(.*?)(?=\n\nDIRECTOR|\n\nCAST|\n\nCREDITS|$)/is,
        /LOGLINE\s+(.*?)(?=\n\n(?:DIRECTOR|CAST|CREDITS|ABOUT)|$)/is
    ];
    
    for (const pattern of synopsisPatterns) {
        const match = cleanedText.match(pattern);
        if (match && match[1] && match[1].length > 100) {
            let synopsis = match[1].trim();
            synopsis = synopsis.replace(/^(SYNOPSIS|LOGLINE)\s*/i, '').trim();
            synopsis = synopsis.replace(/\n\s*\n/g, '||PARAGRAPH||').replace(/\n/g, ' ').replace(/\|\|PARAGRAPH\|\|/g, '\n\n').replace(/\s+/g, ' ').trim();
            
            if (synopsis.length > 100) {
                if (synopsis.length > 2000) {
                    synopsis = synopsis.substring(0, 2000);
                    const lastPeriod = synopsis.lastIndexOf('.');
                    if (lastPeriod > 1500) {
                        synopsis = synopsis.substring(0, lastPeriod + 1);
                    }
                    synopsis += '...';
                }
                data.synopsis = synopsis;
                break;
            }
        }
    }

    return data;
}

function handleFile(event) {
    const file = event.target.files[0];
    if (!file) return;
    
    if (file.type === 'application/pdf') {
        processPDF(file);
    } else if (file.type === 'text/plain') {
        processTextFile(file);
    } else {
        showToast('Please upload a PDF or text file');
    }
}

async function processPDF(file) {
    try {
        const arrayBuffer = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
        let fullText = '';
        
        for (let i = 1; i <= pdf.numPages; i++) {
            const page = await pdf.getPage(i);
            const textContent = await page.getTextContent();
            const pageText = textContent.items.map(item => item.str).join(' ');
            fullText += pageText + '\n';
        }
        
        parseContent(fullText);
        showToast('PDF processed successfully');
    } catch (error) {
        console.error('PDF processing error:', error);
        showToast('Error processing PDF');
    }
}

async function processTextFile(file) {
    try {
        const text = await file.text();
        parseContent(text);
        showToast('Text file processed successfully');
    } catch (error) {
        console.error('Text file error:', error);
        showToast('Error processing text file');
    }
}

function parseContent(text) {
    document.getElementById('rawTextContent').textContent = text;
    const extractedData = extractMovieData(text);
    displayExtractedData(extractedData);
    fillForm(extractedData);
    document.getElementById('extractionPreview').classList.remove('hidden');
}

function displayExtractedData(data) {
    const container = document.getElementById('extractedData');
    let html = '';
    
    for (const [key, value] of Object.entries(data)) {
        if (value) {
            const label = key.charAt(0).toUpperCase() + key.slice(1);
            html += `<div><strong>${label}:</strong> ${value}</div>`;
        }
    }
    
    container.innerHTML = html || '<div>No data extracted</div>';
}

function fillForm(data) {
    document.getElementById('title').value = data.title || '';
    document.getElementById('director').value = data.director || '';
    document.getElementById('runtime_minutes').value = data.runtime || '';
    document.getElementById('year').value = data.year || '';
    document.getElementById('language').value = data.language || '';
    document.getElementById('distributor').value = data.distributor || '';
    document.getElementById('logline').value = data.logline || '';
    document.getElementById('synopsis').value = data.synopsis || '';
    document.getElementById('criticsQuote').value = data.criticsQuote || '';
}

function toggleRawText() {
    const viewer = document.getElementById('rawTextViewer');
    viewer.classList.toggle('hidden');
}

function copyRawText() {
    const text = document.getElementById('rawTextContent').textContent;
    navigator.clipboard.writeText(text).then(() => {
        showToast('Copied to clipboard');
    });
}

function downloadData() {
    const title = document.getElementById('title').value || 'extracted';
    const data = {
        title: document.getElementById('title').value,
        director: document.getElementById('director').value,
        runtime_minutes: document.getElementById('runtime_minutes').value,
        year: document.getElementById('year').value,
        language: document.getElementById('language').value,
        distributor: document.getElementById('distributor').value,
        logline: document.getElementById('logline').value,
        synopsis: document.getElementById('synopsis').value,
        criticsQuote: document.getElementById('criticsQuote').value
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${title}.json`;
    a.click();
    URL.revokeObjectURL(url);
}

async function uploadImage(file, bucket, folder = '') {
    if (!supabase) {
        throw new Error('Database not connected');
    }
    if (!file.type.startsWith('image/')) {
        throw new Error('Please select an image file');
    }
    if (file.size > 5 * 1024 * 1024) {
        throw new Error('Image must be smaller than 5MB');
    }

    const fileExt = file.name.split('.').pop();
    const fileName = `${Date.now()}-${Math.random().toString(36).substring(2)}.${fileExt}`;
    const filePath = folder ? `${folder}/${fileName}` : fileName;

    try {
        const { data, error } = await supabase.storage.from(bucket).upload(filePath, file);
        if (error) throw error;
        const { data: urlData } = supabase.storage.from(bucket).getPublicUrl(filePath);
        return urlData.publicUrl;
    } catch (error) {
        console.error('Upload error:', error);
        throw error;
    }
}

async function handlePosterUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        showToast('Uploading poster...');
        const url = await uploadImage(file, 'posters');
        document.getElementById('poster_url').value = url;
        document.getElementById('posterImg').src = url;
        document.getElementById('posterPreview').classList.remove('hidden');
        document.querySelector('#posterUpload .upload-placeholder').style.display = 'none';
        showToast('Poster uploaded successfully!');
    } catch (error) {
        showToast('Upload failed: ' + error.message);
    }
}

async function handleWebGraphicsUpload(event) {
    const file = event.target.files[0];
    if (!file) return;

    try {
        showToast('Uploading web graphics...');
        const url = await uploadImage(file, 'web-graphics');
        document.getElementById('web_graphics_url').value = url;
        document.getElementById('webGraphicsImg').src = url;
        document.getElementById('webGraphicsPreview').classList.remove('hidden');
        document.querySelector('#webGraphicsUpload .upload-placeholder').style.display = 'none';
        showToast('Web graphics uploaded successfully!');
    } catch (error) {
        showToast('Upload failed: ' + error.message);
    }
}

function removePosterImage() {
    document.getElementById('poster_url').value = '';
    document.getElementById('posterImg').src = '';
    document.getElementById('posterPreview').classList.add('hidden');
    document.querySelector('#posterUpload .upload-placeholder').style.display = 'block';
    document.getElementById('posterInput').value = '';
}

function removeWebGraphicsImage() {
    document.getElementById('web_graphics_url').value = '';
    document.getElementById('webGraphicsImg').src = '';
    document.getElementById('webGraphicsPreview').classList.add('hidden');
    document.querySelector('#webGraphicsUpload .upload-placeholder').style.display = 'block';
    document.getElementById('webGraphicsInput').value = '';
}

async function editContent(id, type) {
    try {
        const table = type === 'movie' ? 'movies' : type === 'event' ? 'events' : 'galleries';
        const { data, error } = await supabase.from(table).select('*').eq('id', id).single();
        if (error) throw error;
        
        switchTab('importer');
        currentContentType = type;
        document.querySelectorAll('.type-option').forEach(opt => opt.classList.remove('active'));
        document.querySelector(`.type-option:nth-child(${type === 'movie' ? '1' : type === 'event' ? '2' : '3'})`).classList.add('active');
        
        const titleMap = {
            'movie': 'Movie Details',
            'event': 'Event Details', 
            'gallery': 'Gallery Details'
        };
        document.getElementById('formTitle').textContent = titleMap[type] + ' (Editing)';
        document.getElementById('saveButtonText').textContent = `Update ${type.charAt(0).toUpperCase() + type.slice(1)}`;
        
        document.getElementById('title').value = data.title || data.event_name || data.exhibition_title || '';
        document.getElementById('director').value = data.director || data.presenter || data.artist || '';
        document.getElementById('runtime_minutes').value = data.runtime_minutes || data.duration_minutes || '';
        document.getElementById('year').value = data.release_year || data.event_year || data.exhibition_year || '';
        document.getElementById('language').value = data.language || data.event_type || data.art_medium || '';
        document.getElementById('distributor').value = data.distributor || data.venue || data.gallery_space || '';
        document.getElementById('logline').value = data.logline || '';
        document.getElementById('synopsis').value = data.synopsis || data.description || '';
        document.getElementById('criticsQuote').value = data.critics_quote || '';
        document.getElementById('trailerUrl').value = data.trailer_url || '';
        document.getElementById('simpletix_embed_code').value = data.simpletix_embed_code || '';
        
        if (data.poster_url) {
            document.getElementById('poster_url').value = data.poster_url;
            document.getElementById('posterImg').src = data.poster_url;
            document.getElementById('posterPreview').classList.remove('hidden');
            document.querySelector('#posterUpload .upload-placeholder').style.display = 'none';
        }
        
        if (data.web_graphics_url) {
            document.getElementById('web_graphics_url').value = data.web_graphics_url;
            document.getElementById('webGraphicsImg').src = data.web_graphics_url;
            document.getElementById('webGraphicsPreview').classList.remove('hidden');
            document.querySelector('#webGraphicsUpload .upload-placeholder').style.display = 'none';
        }
        
        document.getElementById('saveBtn').setAttribute('data-editing-id', id);
        document.getElementById('saveBtn').setAttribute('data-editing-type', type);
        showToast('Loaded for editing');
        
    } catch (error) {
        console.error('Edit load error:', error);
        showToast('Failed to load item for editing');
    }
}

async function saveContent() {
    if (!supabase) {
        showToast('Database not connected');
        return;
    }
    
    const title = document.getElementById('title').value.trim();
    if (!title) {
        showToast('Please enter a title');
        return;
    }
    
    try {
        const table = currentContentType === 'movie' ? 'movies' : currentContentType === 'event' ? 'events' : 'galleries';
        
        const data = {
            title: title,
            director: document.getElementById('director').value || null,
            runtime_minutes: parseInt(document.getElementById('runtime_minutes').value) || null,
            release_year: parseInt(document.getElementById('year').value) || null,
            language: document.getElementById('language').value || null,
            distributor: document.getElementById('distributor').value || null,
            logline: document.getElementById('logline').value || null,
            synopsis: document.getElementById('synopsis').value || null,
            critics_quote: document.getElementById('criticsQuote').value || null,
            trailer_url: document.getElementById('trailerUrl').value || null,
            simpletix_embed_code: document.getElementById('simpletix_embed_code').value || null,
            poster_url: document.getElementById('poster_url').value || null,
            web_graphics_url: document.getElementById('web_graphics_url').value || null
        };
        
        if (currentContentType === 'event') {
            data.event_name = title;
            data.presenter = data.director;
            data.duration_minutes = data.runtime_minutes;
            data.event_type = data.language;
            data.venue = data.distributor;
            data.event_year = data.release_year;
        } else if (currentContentType === 'gallery') {
            data.exhibition_title = title;
            data.artist = data.director;
            data.art_medium = data.language;
            data.gallery_space = data.distributor;
            data.exhibition_year = data.release_year;
        }
        
        const saveBtn = document.getElementById('saveBtn');
        const editingId = saveBtn.getAttribute('data-editing-id');
        
        if (editingId) {
            const { error } = await supabase.from(table).update(data).eq('id', editingId);
            if (error) throw error;
            showToast('Updated successfully!');
            
            saveBtn.removeAttribute('data-editing-id');
            saveBtn.removeAttribute('data-editing-type');
            document.getElementById('formTitle').textContent = document.getElementById('formTitle').textContent.replace(' (Editing)', '');
            document.getElementById('saveButtonText').textContent = `Save ${currentContentType.charAt(0).toUpperCase() + currentContentType.slice(1)} to Database`;
        } else {
            const { error } = await supabase.from(table).insert([data]);
            if (error) throw error;
            showToast('Saved successfully!');
        }
        
        clearForm();
        loadContent();
        
    } catch (error) {
        console.error('Save error:', error);
        showToast('Failed to save content');
    }
}

async function deleteContent(id, type) {
    if (!confirm('Are you sure you want to delete this item? This action cannot be undone.')) {
        return;
    }
    
    try {
        const table = type === 'movie' ? 'movies' : type === 'event' ? 'events' : 'galleries';
        const { error } = await supabase.from(table).delete().eq('id', id);
        if (error) throw error;
        showToast('Item deleted successfully');
        loadContent();
    } catch (error) {
        console.error('Delete error:', error);
        showToast('Failed to delete item');
    }
}

function clearForm() {
    document.getElementById('title').value = '';
    document.getElementById('director').value = '';
    document.getElementById('runtime_minutes').value = '';
    document.getElementById('year').value = '';
    document.getElementById('language').value = '';
    document.getElementById('distributor').value = '';
    document.getElementById('logline').value = '';
    document.getElementById('synopsis').value = '';
    document.getElementById('criticsQuote').value = '';
    document.getElementById('trailerUrl').value = '';
    document.getElementById('simpletix_embed_code').value = '';
    document.getElementById('poster_url').value = '';
    document.getElementById('web_graphics_url').value = '';
    
    removePosterImage();
    removeWebGraphicsImage();
    document.getElementById('extractionPreview').classList.add('hidden');
    document.getElementById('rawTextViewer').classList.add('hidden');
}

function showToast(message) {
    const existingToast = document.querySelector('.toast');
    if (existingToast) {
        existingToast.remove();
    }
    
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);
    
    setTimeout(() => {
        toast.remove();
    }, 3000);
}

document.addEventListener('DOMContentLoaded', function() {
    initSupabase();
    document.getElementById('fileInput').addEventListener('change', handleFile);
    document.getElementById('posterInput').addEventListener('change', handlePosterUpload);
    document.getElementById('webGraphicsInput').addEventListener('change', handleWebGraphicsUpload);
    
    const uploadSection = document.getElementById('uploadSection');
    uploadSection.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadSection.classList.add('dragover');
    });
    
    uploadSection.addEventListener('dragleave', (e) => {
        e.preventDefault();
        uploadSection.classList.remove('dragover');
    });
    
    uploadSection.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadSection.classList.remove('dragover');
        
        const files = e.dataTransfer.files;
        if (files.length > 0) {
            const file = files[0];
            if (file.type === 'application/pdf' || file.type === 'text/plain') {
                const fileInput = document.getElementById('fileInput');
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                fileInput.files = dataTransfer.files;
                handleFile({ target: { files: [file] } });
            } else {
                showToast('Please drop a PDF or text file');
            }
        }
    });
    
    uploadSection.addEventListener('click', () => {
        document.getElementById('fileInput').click();
    });
    
    document.getElementById('searchInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            searchContent();
        }
    });
});
